/**************************

This class is automatically generated by KFDataTool

***********************/

\#pragma once

\#include "Format/KFDataFormat.h"
\#include "${CLASS}F.h"
#if $export_api==""
	#set $export_api="KFENGINERT_API"
#end if

namespace ${NS}
{
    class $export_api ${CLASS}TypeDef
    {
#if $DEF_ENUM
    public:
        enum ${CLASS}TypeEnum
        {
            UNDEFINED = 0,
    #if $USECLSID 
        #for $kfd in $data.kfddatas 
            KF_ST_ENUM_${kfd.class} = ${kfd.clsid},
        #end for
    #else
        #for $kfd in $data.kfddatas 
            KF_ST_ENUM_${kfd.class} = ${kfd.typeid},
        #end for
    #end if
        };

#end if
    public:
        static ${CLASS}* Create(uint32 keytype);
        static ${CLASS}* Read(KFByteArray& buffarr, ${CLASS}* obj = nullptr);
        static void Write(KFByteArray& buffarr, ${CLASS}* obj, KFDDirtys* dirtys = nullptr);
        static bool Diff(${CLASS}* old_obj, ${CLASS}* new_obj, KFDDirtys* dirtys = nullptr);
        static ${CLASS}* CompactRead(KFByteArray& buffarr, ${CLASS}* obj = nullptr);
        static void CompactWrite(KFByteArray& buffarr, ${CLASS}* obj);
        static ${CLASS}* Clone(${CLASS}* obj);
        static bool Copy(${CLASS}* src, ${CLASS}* dest);
        static kfMap<kfstr,int32> KeyTypes;

    protected:
        static const kfstr& GetClassName(${CLASS}* object);
    };
}
