/**************************

This class is automatically generated by KFDataTool

***********************/

\#pragma once

#if $export_api==""
	#set $export_api="KFENGINERT_API"
#end if
\#include "Format/KFDataFormat.h"
\#include "Pool/KFObjectPool.h"
KF_OPTIMIZE_OFF

#def AccessParam($param,$arg)
#if $param.type == "kfstr" or $param.type == "object"
**((${$param.rawType}**)$arg)#slurp
#else if $param.isKFRef == True
*((${$param.otype}**)$arg)#slurp
#else
*((${$param.rawType}*)$arg)#slurp
#end if
#end def
#*

*#
#def ContainerTypeStr()
#if $container_param.type in ["arr", "mixarr"]
#if $container_param.value_type_prop != None
kfVector<$container_param.value_type_prop.rawType>#slurp
#end if
#else
#if $container_param.key_type_prop != None and $container_param.value_type_prop != None
#if $container_param.type in ["map", "mixmap"]
kfMap<$container_param.key_type_prop.rawType, $container_param.value_type_prop.rawType>#slurp
#else if $container_param.type in ["omap", "mixomap"]
kfOMap<$container_param.key_type_prop.rawType, $container_param.value_type_prop.rawType>#slurp
#end if
#end if
#end if
#end def
#*

*#
#set $container_type_str = $ContainerTypeStr()
namespace ${NS}
{
    class $export_api ${container_name}_methods
    {
    public:
        static ${container_type_str}* New(${container_type_str}* ptr = nullptr)
        {
            if (ptr)
                return KFSingleton<SimpleObjectPool<${container_type_str}>>::Get().New(*ptr);
            else
                return KFSingleton<SimpleObjectPool<${container_type_str}>>::Get().New();
        }

        static void Delete(${container_type_str}* ptr)
        {
            KFSingleton<SimpleObjectPool<${container_type_str}>>::Get().Delete(ptr);
        }

        static void Regist(kfMap<kfname, KFDMethodMeta>& Funcs)
        {
            Funcs.emplace("new",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!retPtr, "retPtr null!");
                auto& arg_list = *argPtr;
                ${container_type_str}* arg = arg_list.size() > 0 ?
                    *(${container_type_str}**)arg_list[0] : nullptr;
                *((${container_type_str}**)retPtr) = New(arg);
            }));

            Funcs.emplace("delete",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                Delete((${container_type_str}*)target);
            }));

        #if $container_param.type in ["arr", "mixarr"]
        #set $param = $container_param.value_type_prop
        #if $param != None
            Funcs.emplace("size",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				return_and_error_msg_if(!retPtr, "retPtr null!");
				auto instance = (${container_type_str}*)target;
                *((int32*)retPtr) = instance->size();
            }));

            Funcs.emplace("resize",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
				auto instance = (${container_type_str}*)target;
				if (arg_list.size() >= 2)
				{
                    instance->resize(*(int32*)arg_list[0], $AccessParam($param,"arg_list[1]"));
				}
				else
				{
                    instance->resize(*(int32*)arg_list[0]);
				}
            }));

            Funcs.emplace("reserve",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
				auto instance = (${container_type_str}*)target;
                instance->reserve(*(int32*)arg_list[0]);
            }));

            Funcs.emplace("get",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!retPtr, "retPtr null!");
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
				auto instance = (${container_type_str}*)target;
				int32 index = *(int32*)arg_list[0];
				return_and_error_msg_if(index >= instance->size(), "array index invalid: %d, size: %llu", index, instance->size());
            #if $param.type == "object" or $param.type == "kfstr"
                *((${$param.rawType}**)retPtr) = &(*instance)[index];
            #else if $param.type == "kfname"
                *((int32*)retPtr) = (*instance)[index];
            #else if $param.isKFRef == True
                *((${$param.otype}**)retPtr) = (*instance)[index].GetPtr();
            #else if $param.type != "null"
                *((${$param.rawType}*)retPtr) = (*instance)[index];
            #end if
            }));

            Funcs.emplace("set",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
				auto instance = (${container_type_str}*)target;
				int32 index = *(int32*)arg_list[0];
				return_and_error_msg_if(index >= instance->size(), "array index invalid: %d, size: %llu", index, instance->size());
                (*instance)[index] = $AccessParam($param,"arg_list[1]");
            }));

            Funcs.emplace("push_back",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
				auto instance = (${container_type_str}*)target;
                instance->push_back($AccessParam($param,"arg_list[0]"));
            }));

            Funcs.emplace("pop_back",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				auto instance = (${container_type_str}*)target;
                instance->pop_back();
            }));

            Funcs.emplace("find",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				return_and_error_msg_if(!retPtr, "retPtr null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 2, "arg list invalid!");
				auto instance = (${container_type_str}*)target;
				if (*(bool*)arg_list[0])
				{
                    auto it = std::find(instance->rbegin(), instance->rend(), $AccessParam($param,"arg_list[1]"));
                    *((${container_type_str}::reverse_iterator**)retPtr) =
                        KFSingleton<SimpleObjectPool<${container_type_str}::reverse_iterator>>::Get().New(it);
				}
				else
				{
                    auto it = std::find(instance->begin(), instance->end(), $AccessParam($param,"arg_list[1]"));
                    *((${container_type_str}::iterator**)retPtr) =
                        KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(it);
				}
            }));

            Funcs.emplace("insert_val",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 3, "arg list invalid!");
				auto instance = (${container_type_str}*)target;
				auto& it = **((${container_type_str}::iterator**)arg_list[0]);
				int32 n = *(int32*)arg_list[1];
				return_and_error_msg_if(n <= 0, "arg 'n' invalid!");
				if (retPtr)
				{
				    auto rit = instance->insert(it, n, $AccessParam($param,"arg_list[2]"));
				    *((${container_type_str}::iterator**)retPtr) =
                        KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(rit);
				}
				else
				{
                    instance->insert(it, n, $AccessParam($param,"arg_list[2]"));
				}
            }));

            Funcs.emplace("insert_range",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 3, "arg list invalid!");
				auto instance = (${container_type_str}*)target;
				auto& it = **((${container_type_str}::iterator**)arg_list[0]);
				auto& it2 = **((${container_type_str}::iterator**)arg_list[1]);
				auto& it3 = **((${container_type_str}::iterator**)arg_list[2]);
				if (retPtr)
				{
				    auto rit = instance->insert(it, it2, it3);
				    *((${container_type_str}::iterator**)retPtr) =
                        KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(rit);
				}
				else
				{
                    instance->insert(it, it2, it3);
				}
            }));

            Funcs.emplace("erase_range",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 2, "arg list invalid!");
				auto instance = (${container_type_str}*)target;
				auto& it = **((${container_type_str}::iterator**)arg_list[0]);
				if (*(${container_type_str}::iterator**)arg_list[1])
				{
                    auto& it2 = **((${container_type_str}::iterator**)arg_list[1]);
                    if (retPtr)
                    {
                        auto rit = instance->erase(it, it2);
                        *((${container_type_str}::iterator**)retPtr) =
                            KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(rit);
                    }
                    else
                    {
                        instance->erase(it, it2);
                    }
				}
				else
				{
                    if (retPtr)
                    {
                        auto rit = instance->erase(it);
                        *((${container_type_str}::iterator**)retPtr) =
                            KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(rit);
                    }
                    else
                    {
                        instance->erase(it);
                    }
				}
            }));

            Funcs.emplace("swap",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list invalid!");
                auto& x = **(${container_type_str}**)arg_list[0];
				auto instance = (${container_type_str}*)target;
                instance->swap(x);
            }));

            Funcs.emplace("clear",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				auto instance = (${container_type_str}*)target;
                instance->clear();
            }));

            Funcs.emplace("begin",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				return_and_error_msg_if(!retPtr, "retPtr null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
				auto instance = (${container_type_str}*)target;
				if (*(bool*)arg_list[0])
				{
                    auto it = instance->rbegin();
                    *((${container_type_str}::reverse_iterator**)retPtr) =
                        KFSingleton<SimpleObjectPool<${container_type_str}::reverse_iterator>>::Get().New(it);
				}
				else
				{
                    auto it = instance->begin();
                    *((${container_type_str}::iterator**)retPtr) =
                        KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(it);
				}
            }));

            Funcs.emplace("end",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				return_and_error_msg_if(!retPtr, "retPtr null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
				auto instance = (${container_type_str}*)target;
				if (*(bool*)arg_list[0])
				{
                    auto it = instance->rend();
                    *((${container_type_str}::reverse_iterator**)retPtr) =
                        KFSingleton<SimpleObjectPool<${container_type_str}::reverse_iterator>>::Get().New(it);
				}
				else
				{
                    auto it = instance->end();
                    *((${container_type_str}::iterator**)retPtr) =
                        KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(it);
				}
            }));

            Funcs.emplace("new_iterator",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!retPtr, "retPtr null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
                bool reverse = *(bool*)arg_list[0];
                ${container_type_str}::iterator* arg = arg_list.size() > 1 ?
                    *(${container_type_str}::iterator**)arg_list[1] : nullptr;
                if (arg)
                {
                    if (reverse)
                    {
                        *((${container_type_str}::reverse_iterator**)retPtr) =
                            KFSingleton<SimpleObjectPool<${container_type_str}::reverse_iterator>>::Get().New(*arg);
                    }
                    else
                    {
                        *((${container_type_str}::iterator**)retPtr) =
                            KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(*arg);
                    }
                }
                else
                {
                    if (reverse)
                    {
                        *((${container_type_str}::reverse_iterator**)retPtr) =
                            KFSingleton<SimpleObjectPool<${container_type_str}::reverse_iterator>>::Get().New();
                    }
                    else
                    {
                        *((${container_type_str}::iterator**)retPtr) =
                            KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New();
                    }
                }
            }));

            Funcs.emplace("delete_iterator",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
                if (*(bool*)arg_list[0])
                {
                    KFSingleton<SimpleObjectPool<${container_type_str}::reverse_iterator>>::Get().Delete(
                        (${container_type_str}::reverse_iterator*)target);
                }
                else
                {
                    KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().Delete(
                        (${container_type_str}::iterator*)target);
                }
            }));

            Funcs.emplace("iterator_value",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
				auto& val = *(bool*)arg_list[0] ?
				    **((${container_type_str}::reverse_iterator*)target) :
				    **((${container_type_str}::iterator*)target);
                if (retPtr)
                {
                #if $param.type == "object" or $param.type == "kfstr"
                    *((${$param.rawType}**)retPtr) = &val;
                #else if $param.type == "kfname"
                    *((int32*)retPtr) = val;
                #else if $param.isKFRef == True
                    *((${$param.otype}**)retPtr) = val.GetPtr();
                #else if $param.type != "null"
                    *((${$param.rawType}*)retPtr) = val;
                #end if
                }
            }));

            Funcs.emplace("iterator_compare",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				return_and_error_msg_if(!retPtr, "retPtr null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 3, "arg list invalid!");
				int32 compareType = *(int32*)arg_list[1];
				if (*(bool*)arg_list[0])
				{
                    auto& it = *((${container_type_str}::reverse_iterator*)target);
                    auto& it2 = **((${container_type_str}::reverse_iterator**)arg_list[2]);
                    switch(compareType)
                    {
                        case 1:
                            *((bool*)retPtr) = (it == it2);
                            break;
                        case 2:
                            *((bool*)retPtr) = (it > it2);
                            break;
                        case 3:
                            *((bool*)retPtr) = (it < it2);
                            break;
                        default: break;
                    }
				}
				else
				{
                    auto& it = *((${container_type_str}::iterator*)target);
                    auto& it2 = **((${container_type_str}::iterator**)arg_list[2]);
                    switch(compareType)
                    {
                        case 1:
                            *((bool*)retPtr) = (it == it2);
                            break;
                        case 2:
                            *((bool*)retPtr) = (it > it2);
                            break;
                        case 3:
                            *((bool*)retPtr) = (it < it2);
                            break;
                        default: break;
                    }
				}
            }));

            Funcs.emplace("iterator_inc",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 2, "arg list invalid!");
				int32 i = *(int32*)arg_list[1];
				if (*(bool*)arg_list[0])
				{
                    auto& it = *((${container_type_str}::reverse_iterator*)target);
                    it += i;
				}
				else
				{
                    auto& it = *((${container_type_str}::iterator*)target);
                    it += i;
				}
            }));

            Funcs.emplace("iterator_diff",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				return_and_error_msg_if(!retPtr, "retPtr null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 2, "arg list invalid!");
				if (*(bool*)arg_list[0])
				{
                    auto& it = *((${container_type_str}::reverse_iterator*)target);
                    auto& it2 = **((${container_type_str}::reverse_iterator**)arg_list[1]);
                    *(int32*)retPtr = static_cast<int32>(it - it2);
				}
				else
				{
                    auto& it = *((${container_type_str}::iterator*)target);
                    auto& it2 = **((${container_type_str}::iterator**)arg_list[1]);
                    *(int32*)retPtr = static_cast<int32>(it - it2);
				}
            }));
        #end if
        #else
        #set $keyparam = $container_param.key_type_prop
        #set $valueparam = $container_param.value_type_prop
        #if $keyparam != None and $valueparam != None
            #set $isump = True
            #if $container_param.type in ["omap", "mixomap"]
                #set $isump = False
            #end if
            Funcs.emplace("size",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				return_and_error_msg_if(!retPtr, "retPtr null!");
				auto instance = (${container_type_str}*)target;
                *((int32*)retPtr) = instance->size();
            }));

            Funcs.emplace("find",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
				auto instance = (${container_type_str}*)target;
				auto it = instance->find($AccessParam($keyparam,"arg_list[0]"));
				if (retPtr)
				{
                     *((${container_type_str}::iterator**)retPtr) =
                        KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(it);
				}
            }));

            Funcs.emplace("access",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
				auto instance = (${container_type_str}*)target;
				auto& val = (*instance)[$AccessParam($keyparam,"arg_list[0]")];
                #set $param = $valueparam
                if (retPtr)
                {
                #if $param.type == "object" or $param.type == "kfstr"
                    *((${$param.rawType}**)retPtr) = &val;
                #else if $param.type == "kfname"
                    *((int32*)retPtr) = val;
                #else if $param.isKFRef == True
                    *((${$param.otype}**)retPtr) = val.GetPtr();
                #else if $param.type != "null"
                    *((${$param.rawType}*)retPtr) = val;
                #end if
                }
            }));

            Funcs.emplace("set",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 2, "arg list invalid!");
				auto instance = (${container_type_str}*)target;
                (*instance)[$AccessParam($keyparam,"arg_list[0]")] = $AccessParam($valueparam,"arg_list[1]");
            }));

            Funcs.emplace("insert",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 2, "arg list invalid!");
				auto instance = (${container_type_str}*)target;
				if (retPtr)
				{
                    *((bool*)retPtr) = (*instance).insert(
                        std::make_pair($AccessParam($keyparam,"arg_list[0]"),
                            $AccessParam($valueparam,"arg_list[1]"))).second;
				}
				else
				{
                    (*instance).insert(
                        std::make_pair($AccessParam($keyparam,"arg_list[0]"),
                            $AccessParam($valueparam,"arg_list[1]")));
				}
            }));

            Funcs.emplace("erase",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
				auto instance = (${container_type_str}*)target;
				if (retPtr)
				{
                    *((int32*)retPtr) = (*instance).erase($AccessParam($keyparam,"arg_list[0]"));
				}
				else
				{
                    (*instance).erase($AccessParam($keyparam,"arg_list[0]"));
				}
            }));

            Funcs.emplace("erase_range",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 2, "arg list invalid!");
				auto instance = (${container_type_str}*)target;
				auto& it = **((${container_type_str}::iterator**)arg_list[0]);
				if (arg_list[1])
				{
                    auto& it2 = **((${container_type_str}::iterator**)arg_list[1]);
                    if (retPtr)
                    {
                        auto rit = instance->erase(it, it2);
                        *((${container_type_str}::iterator**)retPtr) =
                            KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(rit);
                    }
                    else
                    {
                        instance->erase(it, it2);
                    }
				}
				else
				{
                    if (retPtr)
                    {
                        auto rit = instance->erase(it);
                        *((${container_type_str}::iterator**)retPtr) =
                            KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(rit);
                    }
                    else
                    {
                        instance->erase(it);
                    }
				}
            }));

            Funcs.emplace("swap",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list invalid!");
                auto& x = **(${container_type_str}**)arg_list[0];
				auto instance = (${container_type_str}*)target;
                instance->swap(x);
            }));

            Funcs.emplace("clear",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				auto instance = (${container_type_str}*)target;
                instance->clear();
            }));

            Funcs.emplace("begin",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				return_and_error_msg_if(!retPtr, "retPtr null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
			#if isump == True
				return_and_error_msg_if(*(bool*)arg_list[0], "unorder map not has rbegin!");
			#end if
				auto instance = (${container_type_str}*)target;
			#if isump == True
                auto it = instance->begin();
                *((${container_type_str}::iterator**)retPtr) =
                    KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(it);
			#else
				if (*(bool*)arg_list[0])
				{
                    auto it = instance->rbegin();
                    *((${container_type_str}::reverse_iterator**)retPtr) =
                        KFSingleton<SimpleObjectPool<${container_type_str}::reverse_iterator>>::Get().New(it);
				}
				else
				{
                    auto it = instance->begin();
                    *((${container_type_str}::iterator**)retPtr) =
                        KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(it);
				}
			#end if
            }));

            Funcs.emplace("end",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				return_and_error_msg_if(!retPtr, "retPtr null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
			#if isump == True
				return_and_error_msg_if(*(bool*)arg_list[0], "unorder map not has rend!");
			#end if
				auto instance = (${container_type_str}*)target;
			#if isump == True
                auto it = instance->end();
                *((${container_type_str}::iterator**)retPtr) =
                    KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(it);
			#else
				if (*(bool*)arg_list[0])
				{
                    auto it = instance->rend();
                    *((${container_type_str}::reverse_iterator**)retPtr) =
                        KFSingleton<SimpleObjectPool<${container_type_str}::reverse_iterator>>::Get().New(it);
				}
				else
				{
                    auto it = instance->begin();
                    *((${container_type_str}::iterator**)retPtr) =
                        KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(it);
				}
			#end if
            }));

            Funcs.emplace("new_iterator",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!retPtr, "retPtr null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
                ${container_type_str}::iterator* arg = arg_list.size() > 1 ?
                    *(${container_type_str}::iterator**)arg_list[1] : nullptr;
                if (arg)
                {
                #if $isump == True
                    *((${container_type_str}::iterator**)retPtr) =
                        KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(*arg);
                #else
                    if (*(bool*)arg_list[0])
                    {
                        *((${container_type_str}::reverse_iterator**)retPtr) =
                            KFSingleton<SimpleObjectPool<${container_type_str}::reverse_iterator>>::Get().New(*arg);
                    }
                    else
                    {
                        *((${container_type_str}::iterator**)retPtr) =
                            KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New(*arg);
                    }
                #end if
                }
                else
                {
                #if $isump == True
                    *((${container_type_str}::iterator**)retPtr) =
                        KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New();
                #else
                    if (*(bool*)arg_list[0])
                    {
                        *((${container_type_str}::reverse_iterator**)retPtr) =
                            KFSingleton<SimpleObjectPool<${container_type_str}::reverse_iterator>>::Get().New();
                    }
                    else
                    {
                        *((${container_type_str}::iterator**)retPtr) =
                            KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().New();
                    }
                #end if
                }
            }));

            Funcs.emplace("delete_iterator",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
			#if $isump == True
                KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().Delete(
                    (${container_type_str}::iterator*)target);
			#else
                if (*(bool*)arg_list[0])
                {
                    KFSingleton<SimpleObjectPool<${container_type_str}::reverse_iterator>>::Get().Delete(
                        (${container_type_str}::reverse_iterator*)target);
                }
                else
                {
                    KFSingleton<SimpleObjectPool<${container_type_str}::iterator>>::Get().Delete(
                        (${container_type_str}::iterator*)target);
                }
            #end if
            }));

            Funcs.emplace("iterator_first",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				return_and_error_msg_if(!retPtr, "retPtr null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
			#if $isump == True
				auto& val = (*((${container_type_str}::iterator*)target))->first;
			#else
				auto& val = *(bool*)arg_list[0] ?
				    (*((${container_type_str}::reverse_iterator*)target))->first :
				    (*((${container_type_str}::iterator*)target))->first;
			#end if
            #set $param = $keyparam
            #if $param.type == "object" or $param.type == "kfstr"
                *((${$param.rawType}**)retPtr) = &val;
            #else if $param.type == "kfname"
                *((int32*)retPtr) = val;
            #else if $param.isKFRef == True
                *((${$param.otype}**)retPtr) = val.GetPtr();
            #else if $param.type != "null"
                *((${$param.rawType}*)retPtr) = val;
            #end if
            }));

            Funcs.emplace("iterator_second",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				return_and_error_msg_if(!retPtr, "retPtr null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list empty!");
			#if $isump == True
				auto& val = (*((${container_type_str}::iterator*)target))->second;
			#else
				auto& val = *(bool*)arg_list[0] ?
				    (*((${container_type_str}::reverse_iterator*)target))->second :
				    (*((${container_type_str}::iterator*)target))->second;
			#end if
            #set $param = $valueparam
            #if $param.type == "object" or $param.type == "kfstr"
                *((${$param.rawType}**)retPtr) = &val;
            #else if $param.type == "kfname"
                *((int32*)retPtr) = val;
            #else if $param.isKFRef == True
                *((${$param.otype}**)retPtr) = val.GetPtr();
            #else if $param.type != "null"
                *((${$param.rawType}*)retPtr) = val;
            #end if
            }));

            Funcs.emplace("iterator_eq",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				return_and_error_msg_if(!retPtr, "retPtr null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 2, "arg list invalid!");
			#if $isump == True
                auto& it = *((${container_type_str}::iterator*)target);
                auto& it2 = **((${container_type_str}::iterator**)arg_list[1]);
                *((bool*)retPtr) = (it == it2);
			#else
				if (*(bool*)arg_list[0])
				{
                    auto& it = *((${container_type_str}::reverse_iterator*)target);
                    auto& it2 = **((${container_type_str}::reverse_iterator**)arg_list[1]);
                    *((bool*)retPtr) = (it == it2);
				}
				else
				{
                    auto& it = *((${container_type_str}::iterator*)target);
                    auto& it2 = **((${container_type_str}::iterator**)arg_list[1]);
                    *((bool*)retPtr) = (it == it2);
				}
			#end if
            }));

            Funcs.emplace("iterator_inc",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list invalid!");
			#if $isump == True
                auto& it = *((${container_type_str}::iterator*)target);
                ++it;
			#else
				if (*(bool*)arg_list[0])
				{
                    auto& it = *((${container_type_str}::reverse_iterator*)target);
                    ++it;
				}
				else
				{
                    auto& it = *((${container_type_str}::iterator*)target);
                    ++it;
				}
			#end if
            }));
        #if $isump != True

            Funcs.emplace("iterator_dec",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list invalid!");
				if (*(bool*)arg_list[0])
				{
                    auto& it = *((${container_type_str}::reverse_iterator*)target);
                    --it;
				}
				else
				{
                    auto& it = *((${container_type_str}::iterator*)target);
                    --it;
				}
            }));
        #end if
        #end if
        #end if
        }
    };
}
KF_OPTIMIZE_ON
