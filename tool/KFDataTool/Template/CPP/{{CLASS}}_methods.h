/**************************

This class is automatically generated by KFDataTool

***********************/

\#pragma once

#if $len($data.includes) > 0
\#include "$data.includes[0]"
#end if
#if $export_api==""
	#set $export_api="KFENGINERT_API"
#end if
\#include "GC/KFGCSystem.h"
\#include "Format/KFDataFormat.h"
\#include "Pool/KFObjectPool.h"
\#include "VM3/wrap/KF8FunctionLink.h"
#for $funcInclude in $funcsincludes
#if $funcInclude != $data.class
\#include "${funcInclude}_methods.h"
#end if
#end for

#if $root_base_class == "KFGCObject"
    #set $isgcobject = True
#else if $root_base_class == "UObject"
    #set $isuobject = True
#end if
#*

*#
#set global $containerTypes = ["arr", "mixarr", "map", "mixmap", "omap", "mixomap"]
#*

*#
#def ParamsValidCheck($params)
    #set $needargnum = 0;
    #for $i in range($len($params))
        #if $params[$i].defaultval != None
            #break
        #else
            #set $needargnum = $needargnum + 1
        #end if
    #end for
    #if $needargnum > 0
				return_and_error_msg_if(arg_size < $needargnum, "arg list size invalid, %llu/$needargnum!", arg_size);
	#end if
    #for $i in range($len($params))
        #if $params[$i].defaultval != None
            #set $condition = "if (arg_size > $i) "
        #else
            #set $condition = ""
        #end if
        #if $params[$i].type == "kfstr" or $params[$i].type == "object"
                ${condition}return_and_error_msg_if(!*((${$params[$i].rawType}**)arg_list[$i]), "arg $i pointer null!");
        #else if $params[$i].type in $containerTypes
            #if $params[$i].isPointer != True
				${condition}return_and_error_msg_if(!*((${$params[$i].rawType}**)arg_list[$i]), "arg $i pointer null!");
            #end if
        #end if
    #end for
#end def
#*

*#
#def Param($param,$i)
#if $param.type == "kfstr" or $param.type == "object"
**(($param.rawType**)arg_list[${$i}])#slurp
#else if $param.type in $containerTypes
#if $param.isPointer == True
*(($param.rawType*)arg_list[${$i}])#slurp
#else
**(($param.rawType**)arg_list[${$i}])#slurp
#end if
#else
*(($param.rawType*)arg_list[${$i}])#slurp
#end if
#end def
#*

*#
#def ParamsList($params)
                #for $i in range($len($params))
                    #if $i + 1 >= $len($params)
                        #set $comma = ""
                    #else
                        #set $comma = ","
                    #end if
                    #if $params[$i].defaultval != None
                        arg_size > $i ? $Param($params[$i],$i) : ($params[$i].rawType)$params[$i].defaultval$comma
                    #else
                        $Param($params[$i],$i)$comma
                    #end if
                #end for
#end def
#*

*#
#def UObjectNew()
                auto size = arg_list.size();
                if (size == 2)
                {
                    *((${data.class}**)retPtr) = NewObject<${data.class}>(*(UObject**)arg_list[0], *((const char**)arg_list[1]));
                }
                else if (size == 0)
                {
                    *((${data.class}**)retPtr) = NewObject<${data.class}>();
                }
                else
                {
                    LOG_ERROR("new arg_list invalid!");
                }
#end def
#*

*#
namespace ${NS}
{
    class $export_api ${data.class}_methods
    {
    public:
    #if "abstract" not in $data or $data.abstract != 1
    #if $isuobject != True
        static ${data.class}* New(${data.class}* ptr = nullptr)
        {
        #if $isgcobject == True
            return kfNewObject(${data.class});
        #else
            if (ptr)
                return KFSingleton<SimpleObjectPool<${data.class}>>::Get().New(*ptr);
            else
                return KFSingleton<SimpleObjectPool<${data.class}>>::Get().New();
        #end if
        }

        static void Delete(${data.class}* ptr)
        {
        #if $isgcobject == True
            kfDeleteObject(ptr);
        #else
            KFSingleton<SimpleObjectPool<${data.class}>>::Get().Delete(ptr);
        #end if
        }
    #end if

    #end if
        static void Regist(kfMap<kfname, KFDMethodMeta>& Funcs)
        {
        #if "abstract" not in $data or $data.abstract != 1
            Funcs.emplace("new",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!retPtr, "retPtr null!");
                auto& arg_list = *argPtr;
            #if $isuobject != True
                ${data.class}* arg = arg_list.size() > 0 ?
                    *(${data.class}**)arg_list[0] : nullptr;
                *((${data.class}**)retPtr) = New(arg);
            #else
$UObjectNew()
            #end if
            }));

        #if $isuobject == True
            Funcs.emplace("retain_ref",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
				return_and_error_msg_if(!retPtr, "retPtr null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list size invalid, %llu/1!", arg_list.size());
				if (*(bool*)arg_list[0])
				{
                    *((TStrongObjectPtr<${data.class}>**)retPtr) = KFSingleton<SimpleObjectPool<TStrongObjectPtr<${data.class}>>>::Get().New((${data.class}*)target);
				}
				else
				{
                    *((TWeakObjectPtr<${data.class}>**)retPtr) = KFSingleton<SimpleObjectPool<TWeakObjectPtr<${data.class}>>>::Get().New((${data.class}*)target);
				}
            }));

            Funcs.emplace("release_ref",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                auto& arg_list = *argPtr;
				return_and_error_msg_if(arg_list.size() < 1, "arg list size invalid, %llu/1!", arg_list.size());
				if (*(bool*)arg_list[0])
				{
                    KFSingleton<SimpleObjectPool<TStrongObjectPtr<${data.class}>>>::Get().Delete((TStrongObjectPtr<${data.class}>*)target);
				}
				else
				{
                    KFSingleton<SimpleObjectPool<TWeakObjectPtr<${data.class}>>>::Get().Delete((TWeakObjectPtr<${data.class}>*)target);
				}
            }));
        #else
            Funcs.emplace("delete",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
				return_and_error_msg_if(!target, "target null!");
                Delete((${data.class}*)target);
            }));
        #end if
        #end if
#if "funcs" in $data
    #for $func in $data.funcs
        #if $func.gen != False
            #if "alias" in $func:
                #set $funcName = $func.alias
            #else
                #set $funcName = $func.name
            #end if

            Funcs.emplace("${funcName}",KFDMethodMeta([](kfAny target,kfAny retPtr,kfVector<kfAny>* argPtr){
        	#if "isStatic" not in $func
                return_and_error_msg_if(!target, "target null!");
                ${data.class}* instance = (${data.class}*) target;
                #set $funcCall = 'instance->'
            #else
                #set $funcCall = $data.class + '::'
            #end if
        	#if $len($func.params) > 0
        	    auto& arg_list = *argPtr;
        	    auto arg_size = arg_list.size();
$ParamsValidCheck($func.params)#slurp
        	#end if
            #if $len($func.params) > 0
                #set $endCallStr = ""
            #else
                #set $endCallStr = ");"
            #end if
                if(retPtr)
                {
            #if $func.retparam.type == "object"
                #if $func.retparam.isRef == True
                    *((${$func.retparam.rawType}**)retPtr) = &${funcCall}${func.name}($endCallStr
                #else
                    auto ret = ${$func.retparam.rawType}_methods::New();
                    return_and_error_msg_if(!ret, "${$func.retparam.rawType}_methods new fail!");
                    *ret = ${funcCall}${func.name}($endCallStr
                #end if
            #else if $func.retparam.type in $containerTypes
                #if $func.retparam.isRef == True
                    *((${$func.retparam.rawType}**)retPtr) = &${funcCall}${func.name}($endCallStr
                #else if $func.retparam.isPointer == True
                    *((${$func.retparam.rawType}*)retPtr) = ${funcCall}${func.name}($endCallStr
                #else
                    auto ret = ${$func.retparam.containerTypeName}_methods::New();
                    return_and_error_msg_if(!ret, "${$func.retparam.containerTypeName}_methods new fail!");
                    *ret = ${funcCall}${func.name}($endCallStr
                #end if
            #else if $func.retparam.type == "kfstr"
                #if $func.retparam.isRef == True
                    *((${$func.retparam.rawType}**)retPtr) = &${funcCall}${func.name}($endCallStr
                #else
                    auto ret = VMString::StrPool.New();
                    return_and_error_msg_if(!ret, "VMString::StrPool new fail!");
                    *ret = ${funcCall}${func.name}($endCallStr
                #end if
            #else if $func.retparam.type == "kfname"
                    *((int32*)retPtr) = ${funcCall}${func.name}($endCallStr
            #else if $func.retparam.type != "null"
                    *((${$func.retparam.rawType}*)retPtr) = ${funcCall}${func.name}($endCallStr
            #else
                    ${funcCall}${func.name}($endCallStr
            #end if
        #if $len($func.params) > 0
$ParamsList($func.params)#slurp
                    );
        #end if
                #if ($func.retparam.type == "object" or $func.retparam.type == "kfstr") and $func.retparam.isRef != True
                    *((${$func.retparam.rawType}**)retPtr) = ret;
                #end if
                }
                else
                {
            	    ${funcCall}${func.name}($endCallStr
        #if $len($func.params) > 0
$ParamsList($func.params)#slurp
                    );
        #end if
                }
            }, KFDMethodMeta::TypeMeta((KFDataType)$type2ids.get($func.retparam.type, 0),"${func.retparam.otype}")));
        #end if
    #end for
#end if
        }
    };
}
