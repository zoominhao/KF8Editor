/**************************

This class is automatically generated by KFDataTool

***********************/
\#pragma once

\#include "Format/KFDataFormat.h"
#for $includestr in $data.includes 
\#include "${includestr}"
#end for
#if $data.extend 
\#include "${data.extend}F.h"
#end if

#if $export_api==""
	#set $export_api="KFENGINERT_API"
#end if
namespace ${NS} {
    class $export_api ${data.class}F {
    public:
        static ${data.class}* Read(KFByteArray& buffarr,${data.class}* obj = nullptr);
        static void Write(KFByteArray& buffarr,${data.class}* obj,KFDDirtys* dirtys = nullptr);
        static bool Diff(${data.class}* old_obj,${data.class}* new_obj,KFDDirtys* dirtys = nullptr);
        static ${data.class}* CompactRead(KFByteArray& buffarr,${data.class}* obj = nullptr);
        static void CompactWrite(KFByteArray& buffarr,${data.class}* obj);

        static ${data.class}* Read${data.class}(KFByteArray& buffarr,${data.class}* obj = nullptr);
        static void Write${data.class}(KFByteArray& buffarr,${data.class}* obj, KFDDirtys* dirtys = nullptr);
        static bool Diff${data.class}(${data.class}* old_obj,${data.class}* new_obj,KFDDirtys* dirtys = nullptr);
        static ${data.class}* CompactRead${data.class}(KFByteArray& buffarr,${data.class}* obj = nullptr);
        static void CompactWrite${data.class}(KFByteArray& buffarr,${data.class}* obj);
    };

    class $export_api ${data.class}R {
    public:
        static KFDFieldResult GetField(kfAny obj, const kfname& fieldname, kfAny index);
        static bool SetField(kfAny obj, const kfname& fieldname, kfAny field, kfAny index);
        static kfAny New() { return kfNewObject(${data.class}); }
        static void Delete(kfAny ptr) { kfDeleteObject(static_cast<${data.class}*>(ptr)); }
        static kfAny Clone(kfAny obj);
        static bool Copy(kfAny src, kfAny dest);

        static ${data.class}* Clone${data.class}(${data.class}* obj);
        static bool Copy${data.class}(${data.class}* src, ${data.class}* dest);
    };
}
